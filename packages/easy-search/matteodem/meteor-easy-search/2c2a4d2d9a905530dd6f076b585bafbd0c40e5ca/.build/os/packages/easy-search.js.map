{"version":3,"file":"/packages/easy-search.js","sources":["easy-search/lib/easy-search-server.js"],"names":[],"mappings":";;;;;;;;AAAA,2B;AACA,4B;AACA,kB;AACA,qB;AACA,kB;AACA,8B;AACA,uB;AACA,yB;AACA,U;AACA,sB;AACA,8C;AACA,4B;AACA,a;AACA,U;AACA,8D;AACA,oB;AACA,qC;AACA,4C;AACA,8C;AACA,iB;AACA,c;AACA,U;AACA,8C;AACA,mE;;AAEA,O;AACA,4C;AACA,M;AACA,0B;AACA,wB;AACA,O;AACA,+B;AACA,wB;;AAEA,2C;AACA,oF;AACA,W;;AAEA,sB;AACA,K;;AAEA,O;AACA,6C;AACA,M;AACA,2B;AACA,0B;AACA,yB;AACA,O;AACA,0C;AACA,uB;AACA,gE;AACA,yC;AACA,8C;AACA,4F;AACA,8D;AACA,iB;AACA,c;AACA,oB;AACA,K;;AAEA,O;AACA,wF;AACA,M;AACA,yE;AACA,wD;AACA,O;AACA,iB;AACA,4B;AACA,e;AACA,wE;AACA,c;AACA,mC;AACA,sC;AACA,e;AACA,4D;AACA,iE;AACA,2E;AACA,iB;;AAEA,0D;AACA,kD;AACA,oE;AACA,sB;AACA,oD;AACA,2E;AACA,4F;AACA,sB;AACA,4C;AACA,oF;AACA,yD;AACA,8D;AACA,oG;AACA,8E;AACA,iC;AACA,8B;AACA,oC;AACA,qB;AACA,mB;AACA,c;AACA,e;AACA,6D;AACA,c;AACA,mC;AACA,+B;AACA,e;AACA,wD;AACA,kE;;AAEA,mE;AACA,8D;;AAEA,6D;;AAEA,gD;AACA,mB;AACA,c;AACA,e;AACA,kE;AACA,c;AACA,mC;AACA,2C;AACA,2C;AACA,yC;AACA,2B;AACA,e;AACA,wE;AACA,6B;AACA,gC;AACA,iC;AACA,uC;AACA,0C;;AAEA,mD;AACA,sC;AACA,gC;AACA,iB;;AAEA,yC;AACA,2B;AACA,iB;;AAEA,oF;;AAEA,4B;AACA,sE;AACA,wC;AACA,kB;;AAEA,qD;AACA,yE;AACA,2B;AACA,iB;;AAEA,2D;AACA,mG;AACA,mD;AACA,iE;AACA,qB;;AAEA,iE;AACA,2D;AACA,kC;AACA,4C;;AAEA,oE;AACA,mE;AACA,6B;;AAEA,0C;AACA,2B;AACA,qB;;AAEA,wC;AACA,mB;;AAEA,kC;AACA,a;AACA,U;AACA,sB;AACA,e;AACA,qC;AACA,c;AACA,0B;AACA,6B;AACA,2B;AACA,e;AACA,4D;AACA,+C;AACA,c;AACA,e;AACA,yD;AACA,c;AACA,oC;AACA,2C;AACA,gC;AACA,e;AACA,4D;AACA,+B;AACA,kC;AACA,wC;AACA,4G;;AAEA,wC;AACA,qD;AACA,oC;AACA,iB;;AAEA,qC;AACA,qC;;AAEA,sD;AACA,oC;AACA,6D;;AAEA,qD;AACA,mB;;AAEA,gC;AACA,c;AACA,e;AACA,c;AACA,4D;AACA,c;AACA,mC;AACA,2C;AACA,2B;AACA,e;AACA,sD;AACA,6B;AACA,gC;AACA,0C;;AAEA,yC;AACA,2B;AACA,iB;;AAEA,gD;AACA,mD;;AAEA,qF;AACA,iE;;AAEA,0F;AACA,a;AACA,S;AACA,M;;AAEA,Y;AACA,W;AACA,kD;AACA,U;AACA,oC;AACA,W;AACA,yC;AACA,mD;AACA,8B;AACA,a;;AAEA,iD;AACA,oE;AACA,U;AACA,W;AACA,2E;AACA,U;AACA,+B;AACA,4B;AACA,W;AACA,iD;AACA,uD;AACA,kC;AACA,a;;AAEA,6D;AACA,U;AACA,W;AACA,0F;AACA,U;AACA,+B;AACA,kC;AACA,W;AACA,wD;AACA,2F;AACA,mF;AACA,+F;AACA,2F;;AAEA,oC;;AAEA,gE;AACA,+G;AACA,a;;AAEA,oE;AACA,U;AACA,W;AACA,yD;AACA,U;AACA,+B;AACA,2B;AACA,W;AACA,oD;AACA,8D;;AAEA,+D;AACA,0D;;AAEA,yD;;AAEA,4C;AACA,e;AACA,U;AACA,W;AACA,4B;AACA,U;AACA,+B;AACA,uC;AACA,gC;AACA,qC;AACA,W;AACA,oE;AACA,iD;;AAEA,iE;AACA,oG;AACA,a;;AAEA,wF;AACA,U;AACA,W;AACA,qD;AACA,U;AACA,+B;AACA,8B;AACA,gC;AACA,W;AACA,uD;AACA,wD;AACA,2F;AACA,a;;AAEA,uC;AACA,U;AACA,W;AACA,sC;AACA,oE;AACA,U;AACA,0C;AACA,W;AACA,gD;AACA,uC;AACA,U;AACA,W;AACA,6C;AACA,Y;AACA,oC;AACA,2B;AACA,S;AACA,M;AACA,K;;AAEA,gB;AACA,O;AACA,0C;AACA,M;AACA,2B;AACA,mC;AACA,O;AACA,+C;AACA,qD;AACA,M;AACA,O;AACA,uD;AACA,M;AACA,2B;AACA,0B;AACA,4B;AACA,O;AACA,0D;AACA,yE;AACA,wD;AACA,S;AACA,K;AACA,G","sourcesContent":["EasySearch = (function () {\n    var ElasticSearchClient,\n        Searchers,\n        indexes = {},\n        config = {\n            host: 'localhost',\n            port: 9200,\n            secure: false\n        },\n        conditions = {\n            'onChangeProperty' : function () {\n                return true;\n            }\n        },\n        defaultQuery = function (searchFields, searchString) {\n            return {\n                \"fuzzy_like_this\" : {\n                    \"fields\" : searchFields,\n                    \"like_text\" : searchString\n                }\n            };\n        },\n        Future = Npm.require('fibers/future'),\n        ElasticSearchInstance = Npm.require('elasticsearchclient');\n\n    /**\n     * Return Elastic Search indexable data.\n     *\n     * @param {Object} doc\n     * @returns {Object}\n     */\n    function getESFields(doc) {\n        var newDoc = {};\n\n        _.each(doc, function (value, key) {\n            newDoc[key] = \"string\" === typeof value ? value : JSON.stringify(value);\n        });\n\n        return newDoc;\n    }\n\n    /**\n     * Write a document to a specified index.\n     *\n     * @param {String} name\n     * @param {Object} doc\n     * @param {String} id\n     */\n    function writeToIndex(name, doc, id) {\n        // add to index\n        ElasticSearchClient.index(name, 'default_type', doc, id)\n            .on('data', function (data) {\n                if (config.debug && console) {\n                    console.log('EasySearch: Added / Replaced document to Elastic Search:');\n                    console.log('EasySearch: ' + data + \"\\n\");\n                }\n            })\n            .exec();\n    }\n\n    /**\n     * Searchers which contain all types which can be used to search content, until now:\n     *\n     * elastic-search: Use an elastic search server to search with (fast)\n     * mongo-db: Use mongodb to search (more convenient)\n     */\n    Searchers = {\n        'elastic-search' : {\n            /**\n             * Setup some observers on the mongo db collection provided.\n             *\n             * @param {String} name\n             * @param {Object} options\n             */\n            'createSearchIndex' : function (name, options) {\n                if (\"undefined\" === typeof ElasticSearchClient) {\n                    ElasticSearchClient = new ElasticSearchInstance(config)\n                }\n\n                options.collection.find().observeChanges({\n                    added: function (id, fields) {\n                        writeToIndex(name, getESFields(fields), id);\n                    },\n                    changed: function (id, fields) {\n                        // Overwrites the current document with the new doc\n                        writeToIndex(name, getESFields(options.collection.findOne(id)), id);\n                    },\n                    removed: function (id) {\n                        ElasticSearchClient.deleteDocument(name, 'default_type', id)\n                            .on('data', function (data) {\n                                if (config.debug && console) {\n                                    console.log('EasySearch: Removed document off Elastic Search:');\n                                    console.log('EasySearch: ' + data + \"\\n\");\n                                }\n                            })\n                            .exec();\n                    }\n                });\n            },\n            /**\n             * Get a fake representation of a mongo document.\n             *\n             * @param {Object} data\n             * @returns {Array}\n             */\n            'getMongoDocumentObject' : function (data) {\n                data = _.isString(data) ? JSON.parse(data) : data;\n\n                return _.map(data.hits.hits, function (resultSet) {\n                    var mongoDbDocFake = resultSet['_source'];\n\n                    mongoDbDocFake['_id'] = resultSet['_id'];\n\n                    return resultSet['_source'];\n                });\n            },\n            /**\n             * Perform a search with Elastic Search, using fibers.\n             *\n             * @param {String} name\n             * @param {String} searchString\n             * @param {String|Array} fields\n             * @param {Function} callback\n             * @returns {*}\n             */\n            'search' : function (name, searchString, fields, callback) {\n                var queryObj,\n                    that = this,\n                    searchFields,\n                    fut = new Future(),\n                    index = indexes[name];\n\n                if (\"function\" === typeof fields) {\n                    callback = fields;\n                    fields = [];\n                }\n\n                if (!_.isObject(index)) {\n                    return;\n                }\n\n                searchFields = _.isArray(index.field) ? index.field : [index.field];\n\n                queryObj = {\n                    \"query\" : index.query(searchFields, searchString),\n                    \"size\" : index.limit\n                };\n\n                if (\"function\" === typeof callback) {\n                    ElasticSearchClient.search(name, queryObj, callback);\n                    return;\n                }\n\n                // Most likely client call, return data set\n                ElasticSearchClient.search(name, 'default_type', queryObj, function (error, data) {\n                    if (\"mongo\" === index.format) {\n                        data = that.getMongoDocumentObject(data);\n                    }\n\n                    if (_.isArray(fields) && fields.length > 0) {\n                        data = _.map(data, function (doc) {\n                            var i,\n                                newDoc = {};\n\n                            for (i = 0; i < fields.length; i += 1) {\n                                newDoc[fields[i]] = doc[fields[i]];\n                            }\n\n                            return newDoc;\n                        });\n                    }\n\n                    fut['return'](data);\n                });\n\n                return fut.wait();\n            }\n        },\n        'mongo-db' : {\n            /**\n             * Set up a search index.\n             *\n             * @param name\n             * @param options\n             * @returns {*}\n             */\n            'createSearchIndex' : function (name, options) {\n                // Don't have to setup anything\n            },\n            /**\n             * Get the valid mongodb selector of an index\n             *\n             * @param {Object} index\n             * @param {String} searchString\n             * @returns {Object}\n             */\n            'getSelector' : function (index, searchString) {\n                var orSelector,\n                    selector = {},\n                    field = index.field,\n                    stringSelector = index.exact ? searchString : { '$regex' : '.*' + searchString + '.*' };\n\n                if (_.isString(field)) {\n                    selector[field] = stringSelector;\n                    return selector;\n                }\n\n                // Should be an array\n                selector['$or'] = [];\n\n                _.each(field, function (fieldString) {\n                    orSelector = {};\n                    orSelector[fieldString] = stringSelector;\n\n                    selector['$or'].push(orSelector);\n                });\n\n                return selector;\n            },\n            /**\n             *\n             * Perform a really simple search with mongo db.\n             *\n             * @param {String} name\n             * @param {String} searchString\n             * @returns {*}\n             */\n            'search' : function (name, searchString) {\n                var selector,\n                    that = this,\n                    index = indexes[name];\n\n                if (!_.isObject(index)) {\n                    return;\n                }\n\n                index.limit = index.limit || 10;\n                index.exact = index.exact || false;\n\n                // if several, fields do an $or search, otherwise only over the field\n                selector = that.getSelector(index, searchString);\n\n                return index.collection.find(selector, { 'limit' : index.limit }).fetch();\n            }\n        }\n    };\n\n    return {\n        /**\n         * Override the config for Elastic Search.\n         *\n         * @param {object} newConfig\n         */\n        'config' : function (newConfig) {\n            if (\"undefined\" === typeof newConfig) {\n                return config;\n            }\n\n            config = _.extend(config, newConfig);\n            ElasticSearchClient = new ElasticSearchInstance(config);\n        },\n        /**\n         * Override conditions or return conditions if no parameter passed.\n         *\n         * @param newConditions\n         * @returns {object}\n         */\n        'conditions' : function (newConditions) {\n            if (\"undefined\" === typeof newConditions) {\n                return conditions;\n            }\n\n            conditions = _.extend(conditions, newConditions);\n        },\n        /**\n         * Create a search index for Elastic Search, which resembles a MongoDB Collection.\n         *\n         * @param {String} name\n         * @param {Object} options\n         */\n        'createSearchIndex' : function (name, options) {\n            options.format = \"string\" === typeof options.format ? options.format : \"mongo\";\n            options.limit = \"number\" === typeof options.limit ? options.limit : 10;\n            options.query = \"function\" === typeof options.query ? options.query : defaultQuery;\n            options.use = \"string\" === typeof options.use ? options.use : 'elastic-search';\n\n            indexes[name] = options;\n\n            if (\"undefined\" === typeof Searchers[options.use]) {\n                throw new Meteor.Error(500, \"Didnt find the type: '\" + options.use + \"' to be searched with.\");\n            }\n\n            Searchers[options.use].createSearchIndex(name, options);\n        },\n        /**\n         * Get a fake representation of a mongo document.\n         *\n         * @param {Object} data\n         * @returns {Array}\n         */\n        'getMongoDocumentObject' : function (data) {\n            data = _.isString(data) ? JSON.parse(data) : data;\n\n            return _.map(data.hits.hits, function (resultSet) {\n                var mongoDbDocFake = resultSet['_source'];\n\n                mongoDbDocFake['_id'] = resultSet['_id'];\n\n                return resultSet['_source'];\n            });\n        },\n        /**\n         * Perform a search.\n         *\n         * @param {String} name\n         * @param {String} searchString\n         * @param {Array} fields\n         * @param {Function} callback\n         */\n        'search' : function (name, searchString, fields, callback) {\n            var searcherType = indexes[name].use;\n\n            if (\"undefined\" === typeof Searchers[searcherType]) {\n                throw new Meteor.Error(500, \"Couldnt search with the type: '\" + searcherType + \"'\");\n            }\n\n            return Searchers[searcherType].search(name, searchString, fields, callback);\n        },\n        /**\n         * Change a property specified for the index.\n         *\n         * @param {String} name\n         * @param {String} key\n         * @param {String} value\n         */\n        'changeProperty' : function(name, key, value) {\n            if (!_.isString(name) || !_.isString(key)) {\n                throw new Meteor.Error('name and key of the property have to be strings!');\n            }\n\n            indexes[name][key] = value;\n        },\n        /**\n         * Get the ElasticSearchClient\n         * @see https://github.com/phillro/node-elasticsearch-client\n         *\n         * @return {ElasticSearchInstance}\n         */\n        'getElasticSearchClient' : function () {\n            return ElasticSearchClient;\n        },\n        /**\n          * Retrieve all index configurations\n          */\n        'getIndexes' : function () {\n            return indexes;\n        }\n    };\n})();\n\nMeteor.methods({\n    /**\n     * Make search possible on the client.\n     *\n     * @param {String} name\n     * @param {String} searchString\n     */\n    easySearch: function (name, searchString) {\n        return EasySearch.search(name, searchString);\n    },\n    /**\n     * Make changing properties possible on the client.\n     *\n     * @param {String} name\n     * @param {String} key\n     * @param {String} value\n     */\n    easySearchChangeProperty: function(name, key, value) {\n        if (EasySearch.conditions().onChangeProperty(name, key, value)) {\n            EasySearch.changeProperty(name, key, value);\n        }\n    }\n});\n"]}