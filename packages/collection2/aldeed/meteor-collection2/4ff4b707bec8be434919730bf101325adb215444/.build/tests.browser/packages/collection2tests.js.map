{"version":3,"file":"/packages/collection2:tests.js","sources":["collection2/collection2.tests.js"],"names":[],"mappings":";;;;;;;;AAAA,mB;AACA,wB;AACA,sC;AACA,wB;AACA,O;AACA,G;AACA,C;;AAEA,4C;AACA,4B;AACA,Y;AACA,mB;AACA,qB;AACA,e;AACA,c;AACA,M;AACA,a;AACA,mB;AACA,qB;AACA,M;AACA,a;AACA,mB;AACA,gC;AACA,Y;AACA,M;AACA,qB;AACA,iB;AACA,mD;AACA,oB;AACA,M;AACA,c;AACA,mB;AACA,6B;AACA,qB;AACA,e;AACA,M;AACA,W;AACA,mB;AACA,oB;AACA,qB;AACA,e;AACA,kB;AACA,M;AACA,a;AACA,mB;AACA,oB;AACA,M;AACA,a;AACA,mB;AACA,oB;AACA,M;AACA,gB;AACA,iB;AACA,qB;AACA,sB;AACA,M;AACA,gB;AACA,iB;AACA,qB;AACA,sB;AACA,K;AACA,I;AACA,G;;AAEA,qC;AACA,sB;AACA,O;AACA,6C;AACA,iB;;AAEA,G;AACA,2E;AACA,E;;AAEA,sD;AACA,W;AACA,W;AACA,kB;AACA,M;AACA,kB;AACA,iB;AACA,qB;AACA,6B;AACA,0B;AACA,wC;AACA,S;AACA,O;AACA,M;AACA,gB;AACA,iB;AACA,qB;AACA,6B;AACA,sC;AACA,O;AACA,M;AACA,kB;AACA,mB;AACA,6B;AACA,4B;AACA,mB;AACA,gB;AACA,2B;AACA,S;AACA,O;AACA,M;AACA,c;AACA,mB;AACA,oB;AACA,M;AACA,gB;AACA,mB;AACA,qB;AACA,6B;AACA,4C;AACA,4B;AACA,6C;AACA,gB;AACA,uB;AACA,S;AACA,O;AACA,M;AACA,qB;AACA,qB;AACA,qB;AACA,6B;AACA,4C;AACA,4B;AACA,8B;AACA,qB;AACA,+B;AACA,sC;AACA,iB;AACA,kB;AACA,oB;AACA,sB;AACA,+B;AACA,sC;AACA,e;AACA,c;AACA,W;AACA,S;AACA,O;AACA,M;AACA,8B;AACA,iB;AACA,oB;AACA,M;AACA,iC;AACA,mB;AACA,oB;AACA,K;AACA,G;AACA,G;;AAEA,4D;AACA,4B;AACA,4B;AACA,e;AACA,G;AACA,G;;AAEA,2B;AACA,uB;AACA,E;;AAEA,sB;AACA,wB;AACA,wB;AACA,uC;AACA,I;AACA,qB;AACA,8B;AACA,I;AACA,2B;AACA,qC;AACA,mB;AACA,4D;AACA,I;AACA,wB;AACA,sB;AACA,I;AACA,2B;AACA,8B;AACA,G;AACA,E;;AAEA,2C;AACA,W;AACA,W;AACA,kB;AACA,M;AACA,W;AACA,qB;AACA,oB;AACA,K;AACA,I;AACA,4B;AACA,sC;AACA,e;AACA,G;AACA,G;;AAEA,4C;;AAEA,iE;AACA,6C;AACA,U;AACA,kB;AACA,uB;AACA,G;AACA,I;;AAEA,sD;AACA,4B;AACA,U;AACA,mB;AACA,oB;AACA,M;AACA,uB;AACA,mB;AACA,qB;AACA,8B;AACA,2B;AACA,O;AACA,M;AACA,kC;AACA,oB;AACA,qB;AACA,8B;AACA,sC;AACA,O;AACA,M;AACA,yB;AACA,oB;AACA,qB;AACA,8B;AACA,6B;AACA,O;AACA,M;AACA,yB;AACA,oB;AACA,qB;AACA,8B;AACA,6B;AACA,O;AACA,K;AACA,I;AACA,G;;AAEA,sB;AACA,sC;AACA,wB;AACA,K;;AAEA,2C;AACA,6B;AACA,K;;AAEA,0C;AACA,gC;AACA,K;;AAEA,yC;AACA,qC;AACA,K;;AAEA,sC;AACA,2B;AACA,K;;AAEA,8C;AACA,+B;AACA,K;;AAEA,uB;AACA,wB;AACA,kB;AACA,M;AACA,wB;AACA,kB;AACA,M;AACA,wB;AACA,kB;AACA,K;AACA,K;;AAEA,e;AACA,wB;AACA,kB;AACA,M;AACA,wB;AACA,kB;AACA,M;AACA,wB;AACA,kB;AACA,K;AACA,K;;AAEA,yB;AACA,c;AACA,wB;AACA,wB;AACA,M;AACA,wB;AACA,wB;AACA,M;AACA,wB;AACA,wB;AACA,K;AACA,K;;AAEA,oB;AACA,wB;AACA,kB;AACA,M;AACA,wB;AACA,kB;AACA,M;AACA,wB;AACA,kB;AACA,K;AACA,K;;AAEA,+C;AACA,kB;AACA,yB;AACA,wB;AACA,M;AACA,0B;AACA,yB;AACA,M;AACA,4B;AACA,uB;AACA,4B;AACA,+B;AACA,oC;AACA,0B;AACA,8B;AACA,K;AACA,K;;AAEA,4B;AACA,wB;AACA,kB;AACA,M;AACA,wB;AACA,kB;AACA,K;AACA,K;;AAEA,kB;AACA,wB;AACA,kB;AACA,M;AACA,wB;AACA,kB;AACA,K;AACA,K;;AAEA,sB;AACA,wB;AACA,kB;AACA,M;AACA,wB;AACA,kB;AACA,K;AACA,K;;AAEA,Q;AACA,oD;AACA,iC;AACA,gC;AACA,+B;AACA,4B;AACA,mC;AACA,C;;AAEA,uB;AACA,uD;AACA,C;;AAEA,+D;AACA,oG;AACA,G;;AAEA,sB;AACA,6D;AACA,yE;AACA,gD;AACA,qD;AACA,K;AACA,C;;AAEA,gE;AACA,iC;AACA,G;;AAEA,+B;AACA,yE;AACA,kB;AACA,wB;AACA,c;AACA,wB;AACA,a;AACA,K;AACA,G;;AAEA,4F;AACA,8C;AACA,yG;AACA,4D;AACA,gF;AACA,kG;AACA,wE;AACA,2E;;AAEA,mC;;AAEA,mE;AACA,4E;AACA,gB;AACA,K;;AAEA,sE;AACA,c;AACA,G;;AAEA,wF;AACA,uB;AACA,uE;AACA,qB;AACA,gB;AACA,yH;AACA,iG;AACA,sD;;AAEA,wE;AACA,2E;AACA,sB;AACA,gH;AACA,mG;AACA,wD;;AAEA,0E;AACA,6E;AACA,a;AACA,O;AACA,K;AACA,G;;AAEA,mF;AACA,0G;AACA,iH;AACA,mD;;AAEA,wE;AACA,2E;AACA,mC;;AAEA,+D;AACA,gF;AACA,W;AACA,K;AACA,G;;AAEA,gG;AACA,wB;AACA,oB;AACA,U;AACA,oB;AACA,G;AACA,gB;AACA,wH;AACA,wG;AACA,yD;;AAEA,wE;AACA,2E;AACA,mC;;AAEA,iB;AACA,0H;AACA,yG;AACA,qD;;AAEA,0E;AACA,mH;AACA,qC;AACA,M;AACA,a;AACA,O;AACA,K;AACA,G;;AAEA,mF;AACA,2C;AACA,oD;;AAEA,gF;AACA,iF;AACA,2D;AACA,0C;AACA,yE;;AAEA,sE;AACA,sC;AACA,yE;AACA,S;AACA,G;;AAEA,8E;AACA,kG;AACA,oE;AACA,6H;;AAEA,wE;AACA,qE;AACA,W;AACA,K;AACA,G;;AAEA,iF;AACA,0F;AACA,0E;AACA,+I;;AAEA,wE;AACA,2E;AACA,mC;;AAEA,+D;AACA,gF;AACA,W;AACA,K;AACA,G;;AAEA,6D;AACA,oE;AACA,8D;AACA,wE;AACA,kC;AACA,qC;AACA,c;AACA,mB;AACA,kB;AACA,K;AACA,K;AACA,E;AACA,O;AACA,4C;AACA,e;AACA,iF;AACA,gC;AACA,G;;AAEA,+D;AACA,G;;AAEA,oE;AACA,mH;AACA,kH;;AAEA,wE;AACA,2E;AACA,mC;;AAEA,yE;AACA,8F;;AAEA,W;AACA,K;AACA,G;;AAEA,oE;AACA,gF;AACA,kB;AACA,kH;AACA,2H;;AAEA,wE;AACA,2E;AACA,uF;AACA,oH;;AAEA,0E;AACA,6E;AACA,qC;;AAEA,2E;AACA,gG;;AAEA,2B;AACA,yF;AACA,+H;;AAEA,4E;AACA,+E;AACA,e;AACA,S;AACA,O;AACA,K;AACA,G;;AAEA,sB;AACA,mE;AACA,qF;AACA,iI;AACA,yG;AACA,a;AACA,O;AACA,K;AACA,C;;AAEA,mE;;AAEA,qB;;AAEA,iB;AACA,iB;AACA,wB;AACA,a;AACA,yB;AACA,c;AACA,iB;AACA,O;AACA,M;AACA,I;;AAEA,mD;AACA,kH;AACA,0D;;AAEA,6C;AACA,8D;AACA,gF;AACA,wC;AACA,uC;AACA,mD;AACA,gD;;AAEA,kE;AACA,4B;;AAEA,e;AACA,mB;AACA,0B;AACA,e;AACA,2B;AACA,gB;AACA,mB;AACA,S;AACA,Q;AACA,M;;AAEA,sD;AACA,oH;AACA,4D;;AAEA,gD;AACA,gE;AACA,kF;AACA,0C;AACA,yC;AACA,qD;AACA,kD;;AAEA,a;AACA,O;AACA,K;;AAEA,G;;AAEA,0E;AACA,oG;AACA,gH;AACA,2C;AACA,mC;;AAEA,kH;AACA,8G;AACA,wE;AACA,kF;;AAEA,qE;AACA,wC;AACA,+E;AACA,6C;AACA,qC;;AAEA,2C;AACA,0C;AACA,2H;AACA,O;;AAEA,yC;AACA,wC;AACA,kH;AACA,O;;AAEA,0E;AACA,oF;;AAEA,qF;AACA,+C;AACA,6E;AACA,yC;AACA,wH;AACA,e;AACA,S;AACA,O;AACA,K;AACA,G;;AAEA,0E;AACA,kE;AACA,4F;AACA,gD;AACA,yE;AACA,uC;AACA,sH;AACA,mE;AACA,a;AACA,O;AACA,K;AACA,G;;AAEA,2E;AACA,oD;AACA,uE;AACA,kD;AACA,sE;AACA,wE;AACA,kE;AACA,0B;AACA,4F;AACA,Y;AACA,0F;AACA,K;;AAEA,uF;AACA,gD;AACA,kD;AACA,wE;AACA,0E;AACA,oE;AACA,4B;AACA,8F;AACA,c;AACA,4F;AACA,O;AACA,a;AACA,O;AACA,K;AACA,G;;AAEA,6E;AACA,c;AACA,kD;AACA,iD;AACA,+B;;AAEA,mF;AACA,+D;AACA,mD;AACA,gC;AACA,qF;AACA,iD;AACA,kC;AACA,e;AACA,S;AACA,O;AACA,O;AACA,G;;AAEA,gE;AACA,2C;;AAEA,W;AACA,kI;AACA,sE;AACA,oG;;AAEA,+I;AACA,kE;AACA,oG;;AAEA,S;AACA,6I;AACA,kE;AACA,yE;;AAEA,+I;AACA,kE;AACA,yE;;AAEA,qB;AACA,wG;;AAEA,uD;AACA,0B;AACA,uH;AACA,8E;;AAEA,sE;AACA,6E;AACA,Y;AACA,yH;AACA,K;;AAEA,0H;;AAEA,yD;AACA,4B;AACA,gI;AACA,wE;;AAEA,wE;AACA,+E;AACA,c;AACA,2H;AACA,O;;AAEA,a;AACA,O;AACA,K;AACA,G;;AAEA,qE;AACA,mE;AACA,kE;AACA,+E;AACA,6D;;AAEA,uD;AACA,iC;AACA,4E;;AAEA,2F;AACA,iF;AACA,gF;AACA,2C;AACA,kG;AACA,a;AACA,O;AACA,K;AACA,G;;AAEA,6D;AACA,uC;AACA,mC;AACA,wB;AACA,uC;AACA,I;AACA,S;AACA,W;AACA,kC;AACA,gB;AACA,I;AACA,kC;AACA,gB;AACA,G;AACA,G;;AAEA,4E;AACA,mC;AACA,6D;AACA,sD;AACA,8D;;AAEA,yC;AACA,iC;AACA,8B;;AAEA,iC;AACA,4F;AACA,wD;AACA,gE;;AAEA,2C;AACA,mC;AACA,8B;AACA,I;AACA,wD;AACA,yG;AACA,0D;AACA,8D;;AAEA,6C;AACA,qC;AACA,gC;AACA,e;AACA,S;AACA,O;AACA,K;AACA,G;;AAEA,wE;AACA,Y;AACA,wB;AACA,oC;AACA,U;AACA,oC;AACA,G;;AAEA,sI;AACA,uF;;AAEA,0B;AACA,wH;AACA,2G;AACA,oF;AACA,0I;;AAEA,uD;AACA,6G;AACA,Y;AACA,yE;AACA,kF;AACA,kF;AACA,0E;;AAEA,uD;AACA,4G;AACA,K;;AAEA,0C;AACA,0J;AACA,0F;;AAEA,uE;AACA,sE;AACA,0E;;AAEA,8D;AACA,yF;;AAEA,kJ;AACA,4F;;AAEA,8B;AACA,uH;AACA,+G;AACA,wF;AACA,mJ;;AAEA,wD;AACA,mE;AACA,8H;AACA,gB;AACA,6E;AACA,sF;AACA,sF;AACA,8E;;AAEA,wD;AACA,mE;AACA,qJ;AACA,S;;AAEA,6B;AACA,yI;AACA,8F;AACA,2E;AACA,oF;AACA,+C;AACA,6E;AACA,8E;;AAEA,wD;AACA,mE;AACA,sG;;AAEA,iB;AACA,W;AACA,S;AACA,O;AACA,K;AACA,G;;AAEA,e;AACA,sB;AACA,+E;AACA,uC;AACA,kG;AACA,+F;;AAEA,uD;;AAEA,4E;;AAEA,wE;AACA,2B;AACA,4C;AACA,iB;AACA,W;AACA,S;AACA,O;AACA,K;AACA,C;;AAEA,W;AACA,sB;AACA,qB;AACA,4C;AACA,uB;AACA,oB;AACA,oB;AACA,0B;AACA,gB;AACA,a;AACA,mB;AACA,6B;AACA,0C;AACA,c;AACA,2B;AACA,oB;AACA,c;AACA,gB;AACA,uB","sourcesContent":["function pub(col) {\n  if (Meteor.isServer) {\n    Meteor.publish(null, function () {\n      return col.find();\n    });\n  }\n}\n\nvar books = new Meteor.Collection(\"books\", {\n  schema: new SimpleSchema({\n    title: {\n      type: String,\n      label: \"Title\",\n      max: 200,\n      index: 1\n    },\n    author: {\n      type: String,\n      label: \"Author\"\n    },\n    copies: {\n      type: Number,\n      label: \"Number of copies\",\n      min: 0\n    },\n    lastCheckedOut: {\n      type: Date,\n      label: \"Last date this book was checked out\",\n      optional: true\n    },\n    summary: {\n      type: String,\n      label: \"Brief summary\",\n      optional: true,\n      max: 1000\n    },\n    isbn: {\n      type: String,\n      label: \"ISBN\",\n      optional: true,\n      index: 1,\n      unique: true\n    },\n    field1: {\n      type: String,\n      optional: true\n    },\n    field2: {\n      type: String,\n      optional: true\n    },\n    createdAt: {\n      type: Date,\n      optional: true,\n      denyUpdate: true\n    },\n    updatedAt: {\n      type: Date,\n      optional: true,\n      denyInsert: true\n    }\n  })\n});\n\n// Add one unique index outside of C2\nif (Meteor.isServer) {\n  try {\n    books._dropIndex({field1: 1, field2: 1});\n  } catch (err) {\n\n  }\n  books._ensureIndex({field1: 1, field2: 1}, {unique: true, sparse: true});\n} \n\nvar autoValues = new Meteor.Collection(\"autoValues\", {\n  schema: {\n    name: {\n      type: String\n    },\n    dateDefault: {\n      type: Date,\n      optional: true,\n      autoValue: function() {\n        if (!this.isSet) {\n          return new Date(\"2013-01-01\");\n        }\n      }\n    },\n    dateForce: {\n      type: Date,\n      optional: true,\n      autoValue: function() {\n        return new Date(\"2013-01-01\");\n      }\n    },\n    updateCount: {\n      type: Number,\n      autoValue: function() {\n        if (this.isInsert) {\n          return 0;\n        } else {\n          return {$inc: 1};\n        }\n      }\n    },\n    content: {\n      type: String,\n      optional: true\n    },\n    firstWord: {\n      type: String,\n      optional: true,\n      autoValue: function() {\n        var content = this.field(\"content\");\n        if (content.isSet) {\n          return content.value.split(' ')[0];\n        } else {\n          this.unset();\n        }\n      }\n    },\n    updatesHistory: {\n      type: [Object],\n      optional: true,\n      autoValue: function() {\n        var content = this.field(\"content\");\n        if (content.isSet) {\n          if (this.isInsert) {\n            return [{\n                date: new Date,\n                content: content.value\n              }];\n          } else {\n            return {\n              $push: {\n                date: new Date,\n                content: content.value\n              }\n            };\n          }\n        }\n      }\n    },\n    'updatesHistory.$.date': {\n      type: Date,\n      optional: true\n    },\n    'updatesHistory.$.content': {\n      type: String,\n      optional: true\n    }\n  }\n});\n\nvar noSchemaCollection = new Meteor.Collection('noSchema', {\n  transform: function(doc) {\n    doc.userFoo = \"userBar\";\n    return doc;\n  }\n});\n\nDocument = function(data) {\n  _.extend(this, data);\n};\n\nDocument.prototype = {\n  constructor: Document,\n  toString: function() {\n    return this.toJSONValue.toString();\n  },\n  clone: function() {\n    return new Document(this);\n  },\n  equals: function(other) {\n    if (!(other instanceof Document))\n      return false;\n    return EJSON.stringify(this) === EJSON.stringify(other);\n  },\n  typeName: function() {\n    return \"Document\";\n  },\n  toJSONValue: function() {\n    return _.extend({}, this);\n  }\n};\n\nBlackBox = new Meteor.Collection('black', {\n  schema: {\n    name: {\n      type: String\n    },\n    data: {\n      type: Document,\n      blackbox: true\n    }\n  },\n  transform: function(doc) {\n    doc.data = new Document(doc.data);\n    return doc;\n  }\n});\n\ndefaultValues = new Meteor.Collection(\"dv\");\n\n// Ensure that attaching the schema after constructing works, too\ndefaultValues.attachSchema(new SimpleSchema({\n  bool1: {\n    type: Boolean,\n    defaultValue: false\n  }\n}));\n\ncontextCheck = new Meteor.Collection(\"contextCheck\", {\n  schema: new SimpleSchema({\n    foo: {\n      type: String,\n      optional: true\n    },\n    'context.userId': {\n      type: String,\n      optional: true,\n      autoValue: function () {\n        return this.userId;\n      }\n    },\n    'context.isFromTrustedCode': {\n      type: Boolean,\n      optional: true,\n      autoValue: function () {\n        return this.isFromTrustedCode;\n      }\n    },\n    'context.isInsert': {\n      type: Boolean,\n      optional: true,\n      autoValue: function () {\n        return this.isInsert;\n      }\n    },\n    'context.isUpdate': {\n      type: Boolean,\n      optional: true,\n      autoValue: function () {\n        return this.isUpdate;\n      }\n    }\n  })\n});\n\nif (Meteor.isServer) {\n  Meteor.publish(\"books\", function() {\n    return books.find();\n  });\n\n  Meteor.publish(\"autovalues\", function() {\n    return autoValues.find();\n  });\n\n  Meteor.publish(\"defvalues\", function() {\n    return defaultValues.find();\n  });\n\n  Meteor.publish(\"noschema\", function() {\n    return noSchemaCollection.find();\n  });\n\n  Meteor.publish(\"black\", function() {\n    return BlackBox.find();\n  });\n\n  Meteor.publish(\"contextCheck\", function () {\n    return contextCheck.find();\n  });\n\n  defaultValues.allow({\n    insert: function() {\n      return true;\n    },\n    update: function() {\n      return true;\n    },\n    remove: function() {\n      return true;\n    }\n  });\n\n  books.allow({\n    insert: function() {\n      return true;\n    },\n    update: function() {\n      return true;\n    },\n    remove: function() {\n      return true;\n    }\n  });\n\n  var shouldDeny = false;\n  books.deny({\n    insert: function() {\n      return shouldDeny;\n    },\n    update: function() {\n      return shouldDeny;\n    },\n    remove: function() {\n      return shouldDeny;\n    }\n  });\n\n  autoValues.allow({\n    insert: function() {\n      return true;\n    },\n    update: function() {\n      return true;\n    },\n    remove: function() {\n      return true;\n    }\n  });\n\n  // Rig test helper method for setting denyAll\n  Meteor.methods({\n    denyAll: function() {\n      shouldDeny = true;\n    },\n    allowAll: function() {\n      shouldDeny = false;\n    },\n    removeAll: function () {\n      books.remove({});\n      autoValues.remove({});\n      defaultValues.remove({});\n      noSchemaCollection.remove({});\n      BlackBox.remove({});\n      contextCheck.remove({});\n    }\n  });\n\n  noSchemaCollection.allow({\n    insert: function() {\n      return true;\n    },\n    update: function() {\n      return true;\n    }\n  });\n\n  BlackBox.allow({\n    insert: function() {\n      return true;\n    },\n    update: function() {\n      return true;\n    }\n  });\n\n  contextCheck.allow({\n    insert: function() {\n      return true;\n    },\n    update: function() {\n      return true;\n    }\n  });\n\n} else {\n  var booksSubscription = Meteor.subscribe(\"books\");\n  Meteor.subscribe(\"autovalues\");\n  Meteor.subscribe(\"defvalues\");\n  Meteor.subscribe(\"noschema\");\n  Meteor.subscribe(\"black\");\n  Meteor.subscribe(\"contextCheck\");\n}\n\nfunction equals(a, b) {\n  return !!(EJSON.stringify(a) === EJSON.stringify(b));\n}\n\nTinytest.add('Collection2 - Test Environment', function(test) {\n  test.isTrue(typeof SimpleSchema !== 'undefined', 'test environment not initialized SimpleSchema');\n});\n\nif (Meteor.isServer) {\n  Tinytest.add('Collection2 - Ensure Index', function(test) {\n    // We need to have an access to the getIndexes method of the embedded\n    // collection in order to test this feature.\n    // var indexes = books._collection._getIndexes();\n  });\n}\n\nTinytest.addAsync('Collection2 - Reset', function (test, next) {\n  Meteor.call(\"removeAll\", next);\n});\n\n// Test required field \"copies\"\nTinytest.addAsync('Collection2 - Insert Required', function(test, next) {\n  var numDone = 0;\n  function maybeNext() {\n    numDone++;\n    if (numDone === 2) {\n      next();\n    }\n  }\n\n  var id = books.insert({title: \"Ulysses\", author: \"James Joyce\"}, function(error, result) {\n    //The insert will fail, error will be set,\n    test.isTrue(!!error, 'We expected the insert to trigger an error since field \"copies\" are required');\n    //and result will be false because \"copies\" is required.\n    test.isFalse(result, 'result should be false because \"copies\" is required');\n    //The list of errors is available by calling books.simpleSchema().namedContext().invalidKeys()\n    var invalidKeys = books.simpleSchema().namedContext().invalidKeys();\n    test.equal(invalidKeys.length, 1, 'We should get one invalidKey back');\n\n    var key = invalidKeys[0] || {};\n\n    test.equal(key.name, 'copies', 'We expected the key \"copies\"');\n    test.equal(key.type, 'required', 'We expected the type to be required');\n    maybeNext();\n  });\n\n  test.equal(typeof id, 'string', 'We expected an ID to be returned');\n  maybeNext();\n});\n\n// When unique: true, inserts should fail if another document already has the same value\nvar uniqueBookId, isbn;\nTinytest.addAsync('Collection2 - Unique - Prep', function(test, next) {\n  isbn = Random.id();\n  // Insert isbn\n  uniqueBookId = books.insert({title: \"Ulysses\", author: \"James Joyce\", copies: 1, isbn: isbn}, function(error, result) {\n    test.isFalse(!!error, 'We expected the insert not to trigger an error since isbn is unique');\n    test.isTrue(!!result, 'result should be defined');\n\n    var invalidKeys = books.simpleSchema().namedContext().invalidKeys();\n    test.equal(invalidKeys.length, 0, 'We should get no invalidKeys back');\n    // Insert isbn+\"A\"\n    books.insert({title: \"Ulysses\", author: \"James Joyce\", copies: 1, isbn: isbn+\"A\"}, function(error, result) {\n      test.isFalse(!!error, 'We expected the insert not to trigger an error since isbn is unique');\n      test.isTrue(!!result, 'result should be defined');\n\n      var invalidKeys = books.simpleSchema().namedContext().invalidKeys();\n      test.equal(invalidKeys.length, 0, 'We should get no invalidKeys back');\n      next();\n    });\n  });\n});\n\nTinytest.addAsync('Collection2 - Unique - Insert Duplicate', function(test, next) {\n  books.insert({title: \"Ulysses\", author: \"James Joyce\", copies: 1, isbn: isbn}, function(error, result) {\n    test.isTrue(!!error, 'We expected the insert to trigger an error since isbn being inserted is already used');\n    test.isFalse(result, 'result should be false');\n\n    var invalidKeys = books.simpleSchema().namedContext().invalidKeys();\n    test.equal(invalidKeys.length, 1, 'We should get one invalidKey back');\n    var key = invalidKeys[0] || {};\n\n    test.equal(key.name, 'isbn', 'We expected the key \"isbn\"');\n    test.equal(key.type, 'notUnique', 'We expected the type to be \"notUnique\"');\n    next();\n  });\n});\n\nTinytest.addAsync('Collection2 - Unique - Insert Duplicate Non-C2 Index', function(test, next) {\n  if (Meteor.isServer) {\n    var val = \"foo\";\n  } else {\n    var val = \"bar\";\n  }\n  // Good insert\n  books.insert({title: \"Ulysses\", author: \"James Joyce\", copies: 1, field1: val, field2: val}, function(error, result) {\n    test.isFalse(!!error, 'We expected the insert not to trigger an error since the fields are unique');\n    test.isTrue(!!result, 'result should be the new ID');\n\n    var invalidKeys = books.simpleSchema().namedContext().invalidKeys();\n    test.equal(invalidKeys.length, 0, 'We should get no invalidKeys back');\n    var key = invalidKeys[0] || {};\n\n    // Bad insert\n    books.insert({title: \"Ulysses\", author: \"James Joyce\", copies: 1, field1: val, field2: val}, function(error, result) {\n      test.isTrue(!!error, 'We expected the insert to trigger an error since the fields are not unique');\n      test.isFalse(result, 'result should be false');\n\n      var invalidKeys = books.simpleSchema().namedContext().invalidKeys();\n      test.equal(invalidKeys.length, 0, 'We should get no invalidKeys back because this is a non-C2 unique index');\n      var key = invalidKeys[0] || {};\n      \n      next();\n    });\n  });\n});\n\nTinytest.addAsync('Collection2 - Unique - Validation Alone', function(test, next) {\n  //test validation without actual updating\n  var context = books.simpleSchema().namedContext();\n\n  //we don't know whether this would result in a non-unique value or not because\n  //we don't know which documents we'd be changing; therefore, no notUnique error\n  context.validate({$set: {isbn: isbn}}, {modifier: true});\n  var invalidKeys = context.invalidKeys();\n  test.equal(invalidKeys.length, 0, 'We should get no invalidKeys back');\n\n  context.validateOne({$set: {isbn: isbn}}, \"isbn\", {modifier: true});\n  invalidKeys = context.invalidKeys();\n  test.equal(invalidKeys.length, 0, 'We should get no invalidKeys back');\n  next();\n});\n\nTinytest.addAsync('Collection2 - Unique - Update Self', function(test, next) {\n  // When unique: true, updates should not fail when the document being updated has the same value\n  books.update(uniqueBookId, {$set: {isbn: isbn}}, function(error) {\n    test.isFalse(!!error, 'We expected the update not to trigger an error since isbn is used only by the doc being updated');\n\n    var invalidKeys = books.simpleSchema().namedContext().invalidKeys();\n    test.equal(invalidKeys, [], 'We should get no invalidKeys back');\n    next();\n  });\n});\n\nTinytest.addAsync('Collection2 - Unique - Update Another', function(test, next) {\n  // When unique: true, updates should fail if another document already has the same value\n  books.update(uniqueBookId, {$set: {isbn: isbn + \"A\"}}, function(error) {\n    test.isTrue(!!error, 'We expected the update to trigger an error since isbn we want to change to is already used by a different document');\n\n    var invalidKeys = books.simpleSchema().namedContext().invalidKeys();\n    test.equal(invalidKeys.length, 1, 'We should get one invalidKey back');\n    var key = invalidKeys[0] || {};\n\n    test.equal(key.name, 'isbn', 'We expected the key \"isbn\"');\n    test.equal(key.type, 'notUnique', 'We expected the type to be \"notUnique\"');\n    next();\n  });\n});\n\nvar testCollection = new Meteor.Collection(\"testCollection\");\nTinytest.add('Collection2 - Unique - Object Array', function(test) {\n  // We need to handle arrays of objects specially because the\n  // index key must be \"a.b\" if, for example, the schema key is \"a.$.b\".\n  // Here we make sure that works.\n  var testSchema = new SimpleSchema({\n    'a.$.b': {\n      type: String,\n      unique: true\n    }\n  });\n  \n  try {\n    testCollection.attachSchema(testSchema);\n  } catch (e) {\n    // If we error, that means collection2 tried to set up the index incorrectly,\n    // using the wrong index key\n  }\n\n  test.instanceOf(testCollection.simpleSchema(), SimpleSchema);\n});\n\nTinytest.addAsync(\"Collection2 - denyInsert\", function(test, next) {\n  books.insert({title: \"Ulysses\", author: \"James Joyce\", copies: 1, updatedAt: new Date}, function(error, result) {\n    test.isTrue(!!error, 'We expected the insert to trigger an error since updatedAt has denyInsert set to true');\n\n    var invalidKeys = books.simpleSchema().namedContext().invalidKeys();\n    test.equal(invalidKeys.length, 1, 'We should get one invalidKey back');\n    var key = invalidKeys[0] || {};\n\n    test.equal(key.name, 'updatedAt', 'We expected the key \"updatedAt\"');\n    test.equal(key.type, 'insertNotAllowed', 'We expected the type to be \"insertNotAllowed\"');\n\n    next();\n  });\n});\n\nTinytest.addAsync(\"Collection2 - denyUpdate\", function(test, next) {\n  // Test denyInsert valid case here so that we can use the inserted doc for the\n  // update tests.\n  books.insert({title: \"Ulysses\", author: \"James Joyce\", copies: 1, createdAt: new Date}, function(error, newId) {\n    test.isFalse(!!error, 'We expected the insert not to trigger an error since createdAt denies updates but not inserts');\n\n    var invalidKeys = books.simpleSchema().namedContext().invalidKeys();\n    test.equal(invalidKeys.length, 0, 'We should get no invalidKeys back');\n    books.update({_id: newId}, {$set: {createdAt: new Date}}, function(error, result) {\n      test.isTrue(!!error, 'We expected the insert to trigger an error since createdAt has denyUpdate set to true');\n\n      var invalidKeys = books.simpleSchema().namedContext().invalidKeys();\n      test.equal(invalidKeys.length, 1, 'We should get one invalidKey back');\n      var key = invalidKeys[0] || {};\n\n      test.equal(key.name, 'createdAt', 'We expected the key \"createdAt\"');\n      test.equal(key.type, 'updateNotAllowed', 'We expected the type to be \"updateNotAllowed\"');\n\n      //now test valid case\n      books.update({_id: newId}, {$set: {updatedAt: new Date}}, function(error, result) {\n        test.isFalse(!!error, 'We expected the update not to trigger an error since updatedAt denies inserts but not updates');\n\n        var invalidKeys = books.simpleSchema().namedContext().invalidKeys();\n        test.equal(invalidKeys.length, 0, 'We should get no invalidKeys back');\n        next();\n      });\n    });\n  });\n});\n\nif (Meteor.isServer) {\n  //no validation when calling underlying _collection on the server\n  Tinytest.addAsync(\"Collection2 - _collection on the server\", function(test, next) {\n    books._collection.insert({title: \"Ulysses\", author: \"James Joyce\", copies: 1, updatedAt: new Date}, function(error, result) {\n      test.isFalse(!!error, 'We expected the insert not to trigger an error since we are on the server');\n      next();\n    });\n  });\n}\n\nTinytest.addAsync(\"Collection2 - Black Box\", function(test, next) {\n\n  var now = new Date;\n\n  var boxData = {\n    name: \"Test\",\n    data: new Document({\n      one: 1,\n      two: \"some string\",\n      three: {\n        four: now\n      }\n    })\n  };\n\n  BlackBox.insert(boxData, function(error, newId) {\n    test.isFalse(!!error, 'We expected the insert not to trigger an error since all required fields are present');\n    test.isTrue(!!newId, 'We expected to get an ID back');\n\n    var doc = BlackBox.findOne({_id: newId});\n    test.isTrue(!!doc, 'There should be a document inserted');\n    doc && test.isTrue(doc.data instanceof Document, \"we lost the custom type\");\n    doc && test.equal(doc.name, \"Test\");\n    doc && test.equal(doc.data.one, 1);\n    doc && test.equal(doc.data.two, \"some string\");\n    doc && test.equal(doc.data.three.four, now);\n\n    // remove the EJSON prototype and try again; should still work\n    Document.prototype = {};\n\n    boxData = {\n      name: \"Test\",\n      data: new Document({\n        one: 1,\n        two: \"some string\",\n        three: {\n          four: now\n        }\n      })\n    };\n\n    BlackBox.insert(boxData, function(error, newId2) {\n      test.isFalse(!!error, 'We expected the insert not to trigger an error since all required fields are present');\n      test.isTrue(!!newId, 'We expected to get an ID back');\n\n      var doc = BlackBox.findOne({_id: newId2});\n      test.isTrue(!!doc, 'There should be a document inserted');\n      doc && test.isTrue(doc.data instanceof Document, \"we lost the custom type\");\n      doc && test.equal(doc.name, \"Test\");\n      doc && test.equal(doc.data.one, 1);\n      doc && test.equal(doc.data.two, \"some string\");\n      doc && test.equal(doc.data.three.four, now);\n\n      next();\n    });\n  });\n\n});\n\nTinytest.addAsync(\"Collection2 - AutoValue Insert\", function(test, next) {\n  autoValues.insert({name: \"Test\", firstWord: \"Illegal to manually set value\"}, function(err, res) {\n    test.isFalse(!!err, 'We expected the insert not to trigger an error since all required fields are present');\n    var p = autoValues.findOne({_id: res});\n    var d = new Date(\"2013-01-01\");\n\n    test.equal(p.dateDefault.getTime(), d.getTime(), 'expected the dateDefault to be correctly set after insert');\n    test.equal(p.dateForce.getTime(), d.getTime(), 'expected the dateForce to be correctly set after insert');\n    test.isUndefined(p.firstWord, 'expected firstWord to be undefined');\n    test.isUndefined(p.updatesHistory, 'expected updatesHistory to be undefined');\n\n    // Now test with dateDefault set and verify it is not overwritten\n    var myDate = new Date(\"2013-02-01\");\n    autoValues.insert({name: \"Test\", dateDefault: myDate}, function(err, res) {\n      var p = autoValues.findOne({_id: res});\n      var d = new Date(\"2013-01-01\");\n\n      test.instanceOf(p.dateDefault, Date);\n      if (p.dateDefault instanceof Date) {\n        test.equal(p.dateDefault.getTime(), myDate.getTime(), 'expected the dateDefault to be correctly set after insert');\n      }\n\n      test.instanceOf(p.dateForce, Date);\n      if (p.dateForce instanceof Date) {\n        test.equal(p.dateForce.getTime(), d.getTime(), 'expected the dateForce to be correctly set after insert');\n      }\n\n      test.isUndefined(p.firstWord, 'expected firstWord to be undefined');\n      test.isUndefined(p.updatesHistory, 'expected updatesHistory to be undefined');\n\n      autoValues.insert({name: \"Test\", content: 'Hello world!'}, function(err, res) {\n        var p = autoValues.findOne({_id: res});\n        test.equal(p.firstWord, 'Hello', 'expected firstWord to be \"Hello\"');\n        test.length(p.updatesHistory, 1);\n        test.equal(p.updatesHistory[0].content, 'Hello world!', 'expected updatesHistory.content to be \"Hello world!\"');\n        next();\n      });\n    });\n  });\n});\n\nTinytest.addAsync(\"Collection2 - AutoValue Update\", function(test, next) {\n  autoValues.insert({name: \"Update Test\"}, function(err, testId) {\n    autoValues.update({_id: testId}, {$set: {content: \"Test Content\"}}, function(err, res) {\n      var p = autoValues.findOne({_id: testId});\n      test.equal(p.firstWord, 'Test', 'expected firstWord to be \"Test\"');\n      test.length(p.updatesHistory, 1);\n      test.equal(p.updatesHistory[0].content, 'Test Content', 'expected updatesHistory.content to be \"Test Content\"');\n      test.equal(p.updateCount, 1, 'expected updateCount to be 1');\n      next();\n    });\n  });\n});\n\nTinytest.addAsync(\"Collection2 - AutoValue Context\", function(test, next) {\n  contextCheck.insert({}, function (error, testId) {\n    test.isFalse(!!error, 'insert failed: ' + (error && error.message))\n    var ctx = contextCheck.findOne({_id: testId});\n    test.isTrue(ctx.context.isInsert, 'expected isInsert to be true');\n    test.isFalse(ctx.context.isUpdate, 'expected isUpdate to be false');\n    test.isNull(ctx.context.userId, 'expected userId to be null');\n    if (Meteor.isClient) {\n      test.isFalse(ctx.context.isFromTrustedCode, 'expected isFromTrustedCode to be false');\n    } else {\n      test.isTrue(ctx.context.isFromTrustedCode, 'expected isFromTrustedCode to be true');\n    }\n\n    contextCheck.update({_id: testId}, {$set: {foo: \"bar\"}}, function (error, result) {\n      ctx = contextCheck.findOne({_id: testId});\n      test.equal(ctx.foo, 'bar', \"update failed\");\n      test.isTrue(ctx.context.isUpdate, 'expected isUpdate to be true');\n      test.isFalse(ctx.context.isInsert, 'expected isInsert to be false');\n      test.isNull(ctx.context.userId, 'expected userId to be null');\n      if (Meteor.isClient) {\n        test.isFalse(ctx.context.isFromTrustedCode, 'expected isFromTrustedCode to be false');\n      } else {\n        test.isTrue(ctx.context.isFromTrustedCode, 'expected isFromTrustedCode to be true');\n      }\n      next();\n    });\n  });\n});\n\nTinytest.addAsync(\"Collection2 - DefaultValue Update\", function(test, next) {\n  // Base case\n  defaultValues.insert({}, function(err, testId) {\n    var p = defaultValues.findOne({_id: testId});\n    test.equal(p.bool1, false);\n\n    // Ensure that default values do not mess with inserts and updates of the field\n    defaultValues.insert({bool1: true}, function(err, testId) {\n      var p = defaultValues.findOne({_id: testId});\n      test.equal(p.bool1, true);\n      defaultValues.update({_id: testId}, {$set: {bool1: true}}, function(err, res) {\n        p = defaultValues.findOne({_id: testId});\n        test.equal(p.bool1, true);\n        next();\n      });\n    });\n  });  \n});\n\nTinytest.addAsync('Collection2 - Upsert', function(test, next) {\n  //test validation without actual updating\n\n  //invalid\n  books.simpleSchema().namedContext().validate({$set: {title: \"Ulysses\", author: \"James Joyce\"}}, {modifier: true, upsert: true});\n  var invalidKeys = books.simpleSchema().namedContext().invalidKeys();\n  test.equal(invalidKeys.length, 1, 'We should get one invalidKeys back because copies is missing');\n\n  books.simpleSchema().namedContext().validateOne({$set: {title: \"Ulysses\", author: \"James Joyce\"}}, \"copies\", {modifier: true, upsert: true});\n  invalidKeys = books.simpleSchema().namedContext().invalidKeys();\n  test.equal(invalidKeys.length, 1, 'We should get one invalidKeys back because copies is missing');\n\n  //valid\n  books.simpleSchema().namedContext().validate({$set: {title: \"Ulysses\", author: \"James Joyce\", copies: 1}}, {modifier: true, upsert: true});\n  invalidKeys = books.simpleSchema().namedContext().invalidKeys();\n  test.equal(invalidKeys.length, 0, 'We should get no invalidKeys back');\n\n  books.simpleSchema().namedContext().validateOne({$set: {title: \"Ulysses\", author: \"James Joyce\"}}, \"author\", {modifier: true, upsert: true});\n  invalidKeys = books.simpleSchema().namedContext().invalidKeys();\n  test.equal(invalidKeys.length, 0, 'We should get no invalidKeys back');\n\n  //test update calls\n  books.upsert({title: \"Ulysses\", author: \"James Joyce\"}, {$set: {copies: 1}}, function(error, result) {\n\n    //upserts are server only when this package is used\n    if (Meteor.isServer) {\n      test.isFalse(!!error, 'We expected the upsert not to trigger an error since the selector values should be used');\n      test.equal(result.numberAffected, 1, 'Upsert should update one record');\n\n      invalidKeys = books.simpleSchema().namedContext().invalidKeys();\n      test.equal(invalidKeys.length, 0, 'We should get no invalidKeys back');\n    } else {\n      test.isTrue(!!error, 'We expected the upsert to trigger an error because upserts are not allowed from the client');\n    }\n\n    books.update({title: \"Ulysses\", author: \"James Joyce\"}, {$set: {copies: 1}}, {upsert: true}, function(error, result) {\n\n      //upserts are server only when this package is used\n      if (Meteor.isServer) {\n        test.isFalse(!!error, 'We expected the update/upsert not to trigger an error since the selector values should be used');\n        test.equal(result, 1, 'Update/upsert should update one record');\n\n        invalidKeys = books.simpleSchema().namedContext().invalidKeys();\n        test.equal(invalidKeys.length, 0, 'We should get no invalidKeys back');\n      } else {\n        test.isTrue(!!error, 'We expected the upsert to trigger an error because upserts are not allowed from the client');\n      }\n\n      next();\n    });\n  });\n});\n\n// Ensure that there are no errors when using a schemaless collection\nTinytest.addAsync(\"Collection2 - No Schema\", function(test, next) {\n  noSchemaCollection.insert({a: 1, b: 2}, function(error, newId) {\n    test.isFalse(!!error, 'There should be no error since there is no schema');\n    test.isTrue(!!newId, 'result should be the inserted ID');\n\n    var doc = noSchemaCollection.findOne({_id: newId});\n    test.instanceOf(doc, Object);\n    test.equal(doc.userFoo, \"userBar\", \"User-supplied transforms are lost\");\n\n    noSchemaCollection.update({_id: newId}, {$set: {a: 3, b: 4}}, function(error, result) {\n      test.isFalse(!!error, 'There should be no error since there is no schema');\n      //result is undefined for some reason, but it's happening for apps without\n      //C2 as well, so must be a Meteor bug\n      //test.isTrue(typeof result === \"number\", 'result should be the number of records updated');\n      next();\n    });\n  });\n});\n\n// By default, empty strings are removed, but we can override\nvar RES = new Meteor.Collection(\"RES\");\nRES.attachSchema(new SimpleSchema({\n  foo: { type: String },\n  bar: { type: String, optional: true }\n}));\npub(RES);\nRES.allow({\n  insert: function (userId, doc) {\n    return true;\n  },\n  update: function (userId, doc) {\n    return true;\n  }\n});\n\nTinytest.addAsync(\"Collection2 - removeEmptyStrings\", function(test, next) {\n  // Remove empty strings (default)\n  RES.insert({foo: \"foo\", bar: \"\"}, function(error, newId1) {\n    test.isFalse(!!error, 'There should be no error');\n    test.isTrue(!!newId1, 'result should be the inserted ID');\n\n    var doc = RES.findOne({_id: newId1});\n    test.instanceOf(doc, Object);\n    test.isUndefined(doc.bar);\n\n    // Don't remove empty strings\n    RES.insert({foo: \"foo\", bar: \"\"}, {removeEmptyStrings: false}, function(error, newId2) {\n      test.isFalse(!!error, 'There should be no error');\n      test.isTrue(!!newId2, 'result should be the inserted ID');\n\n      var doc = RES.findOne({_id: newId2});\n      test.instanceOf(doc, Object);\n      test.equal(doc.bar, \"\");\n    \n      // Don't remove empty strings for an update either\n      RES.update({_id: newId1}, {$set: {bar: \"\"}}, {removeEmptyStrings: false}, function(error, result) {\n        test.isFalse(!!error, 'There should be no error');\n        test.equal(result, 1, 'should have updated 1 record');\n\n        var doc = RES.findOne({_id: newId1});\n        test.instanceOf(doc, Object);\n        test.equal(doc.bar, \"\");\n        next();\n      });\n    });\n  });\n});\n\nTinytest.addAsync('Collection2 - Validate False', function(test, next) {\n  var title;\n  if (Meteor.isClient) {\n    title = \"Validate False Client\";\n  } else {\n    title = \"Validate False Server\";\n  }\n\n  books.insert({title: title, author: \"James Joyce\"}, {validate: false, validationContext: \"validateFalse\"}, function(error, result) {\n    var invalidKeys = books.simpleSchema().namedContext(\"validateFalse\").invalidKeys();\n\n    if (Meteor.isClient) {\n      // When validate: false on the client, we should still get a validation error and invalidKeys back from the server\n      test.isTrue(!!error, 'We expected the insert to trigger an error since field \"copies\" are required');\n      test.isFalse(!!result, 'result should be falsy because \"copies\" is required');\n      test.equal(invalidKeys.length, 1, 'There should be 1 invalidKey since validation happened on the server and errors were sent back');\n\n      var insertedBook = books.findOne({title: title});\n      test.isFalse(!!insertedBook, 'Book should not have been inserted because validation failed on server');\n    } else {\n      // When validate: false on the server, validation should be skipped\n      test.isFalse(!!error, 'We expected no error because we skipped validation');\n      test.isTrue(!!result, 'result should be set because we skipped validation');\n      test.equal(invalidKeys.length, 0, 'There should be no invalidKeys');\n\n      var insertedBook = books.findOne({title: title});\n      test.isTrue(!!insertedBook, 'Book should have been inserted because we skipped validation on server');\n    }\n\n    // do a good one to set up update test\n    books.insert({title: title + \" 2\", author: \"James Joyce\", copies: 1}, {validate: false, validationContext: \"validateFalse2\"}, function(error, newId) {\n      var invalidKeys = books.simpleSchema().namedContext(\"validateFalse2\").invalidKeys();\n\n      test.isFalse(!!error, \"We expected no error because it's valid\");\n      test.isTrue(!!newId, \"result should be set because it's valid\");\n      test.equal(invalidKeys.length, 0, 'There should be no invalidKeys');\n\n      var insertedBook = books.findOne({title: title + \" 2\"});\n      test.isTrue(!!insertedBook, 'Book should have been inserted because it was valid');\n\n      books.update({_id: newId}, {$set: {copies: \"Yes Please\"}}, {validate: false, validationContext: \"validateFalse3\"}, function(error, result) {\n        var invalidKeys = books.simpleSchema().namedContext(\"validateFalse3\").invalidKeys();\n\n        if (Meteor.isClient) {\n          // When validate: false on the client, we should still get a validation error and invalidKeys from the server\n          test.isTrue(!!error, 'We expected the insert to trigger an error since field \"copies\" are required');\n          test.isFalse(!!result, 'result should be falsy because \"copies\" is required');\n          test.equal(invalidKeys.length, 1, 'There should be 1 invalidKey since validation happened on the server and invalidKeys were sent back');\n\n          var updatedBook = books.findOne({_id: newId});\n          test.isTrue(!!updatedBook, 'Book should still be there');\n          test.equal(updatedBook.copies, 1, 'copies should still be 1 because our new value failed validation on the server');\n        } else {\n          // When validate: false on the server, validation should be skipped\n          test.isFalse(!!error, 'We expected no error because we skipped validation');\n          test.isTrue(!!result, 'result should be set because we skipped validation');\n          test.equal(invalidKeys.length, 0, 'There should be no invalidKeys');\n\n          var updatedBook = books.findOne({_id: newId});\n          test.isTrue(!!updatedBook, 'Book should still be there');\n          test.equal(updatedBook.copies, \"Yes Please\", 'copies should be changed despite being invalid because we skipped validation on the server');\n        }\n\n        // now try a good one\n        books.update({_id: newId}, {$set: {copies: 3}}, {validate: false, validationContext: \"validateFalse4\"}, function(error, result) {\n          var invalidKeys = books.simpleSchema().namedContext(\"validateFalse4\").invalidKeys();\n          test.isFalse(!!error, \"We expected no error because it's valid\");\n          //result is undefined for some reason, but it's happening for apps without\n          //C2 as well, so must be a Meteor bug\n          //test.isTrue(!!result, \"result should be set because it's valid\");\n          test.equal(invalidKeys.length, 0, 'There should be no invalidKeys');\n\n          var updatedBook = books.findOne({_id: newId});\n          test.isTrue(!!updatedBook, 'Book should still be there');\n          test.equal(updatedBook.copies, 3, 'copies should be changed because we used a valid value');\n\n          next();\n        });\n      });\n    });\n  });\n});\n\n// Test denyAll\nif (Meteor.isClient) {\n  Tinytest.addAsync('Collection2 - Insert Deny Failure', function(test, next) {\n    Meteor.call(\"denyAll\", function() {\n      books.insert({title: \"Ulysses\", author: \"James Joyce\", copies: 1}, function(error, result) {\n        test.isTrue(!!error, 'We expected this to fail since access has to be set explicitly');\n\n        test.isFalse(result, 'result should be false');\n\n        test.equal((error || {}).error, 403, 'We should get Access denied');\n\n        // Clear denyAll settings so that tests work correctly if client\n        // page is reloaded\n        Meteor.call(\"allowAll\", function() {\n          next();\n        });\n      });\n    });\n  });\n}\n\n//Test API:\n//test.isFalse(v, msg)\n//test.isTrue(v, msg)\n//test.equal(actual, expected, message, not)\n//test.length(obj, len)\n//test.include(s, v)\n//test.isNaN(v, msg)\n//test.isUndefined(v, msg)\n//test.isNotNull\n//test.isNull\n//test.throws(func)\n//test.instanceOf(obj, klass)\n//test.notEqual(actual, expected, message)\n//test.runId()\n//test.exception(exception)\n//test.expect_fail()\n//test.ok(doc)\n//test.fail(doc)\n//test.equal(a, b, msg)\n"]}